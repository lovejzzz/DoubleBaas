


# Building a Web-Based SEM-Inspired Synthesizer

## 1. Introduction

This document guides you through building a basic monophonic synthesizer inspired by the classic Oberheim SEM (Synthesizer Expander Module) using web technologies. The goal is a synth that runs in a web browser, has a simple user interface, sounds good (capturing some SEM character), and can be controlled via a MIDI keyboard.

We will use:

*   **HTML:** For the user interface structure (knobs, sliders).
*   **CSS:** For basic styling.
*   **JavaScript:** For the core synthesizer logic.
*   **Web Audio API:** The browser's native audio processing engine.
*   **Tone.js:** A JavaScript library that simplifies working with the Web Audio API, making synth creation much easier.
*   **Web MIDI API:** To connect and receive data from MIDI controllers.

## 2. Core SEM Concepts & Web Audio Mapping

The SEM is known for its relatively simple architecture but powerful and distinct sound, largely due to its unique filter. We'll emulate these key parts:

*   **Two Oscillators (VCOs):** Sawtooth and variable Pulse waveforms. We'll use `Tone.Oscillator` and `Tone.PulseOscillator`. We'll add detuning and subtle LFO modulation for analog-like drift. *Note: True hard sync is complex in basic Web Audio and omitted here for simplicity.*
*   **Mixer:** Blends the two oscillators. We'll use `Tone.Gain` nodes.
*   **State Variable Filter (VCF):** The SEM's heart is its 12dB/octave State Variable Filter, especially its ability to sweep continuously from Low-Pass (LP) through Notch to High-Pass (HP). We'll approximate this using two parallel `Tone.Filter` nodes (LP and HP) blended with a `Tone.CrossFade`.
*   **Two Envelopes (ADSR):** One for the filter cutoff, one for the amplifier (VCA). We'll use `Tone.Envelope` and `Tone.AmplitudeEnvelope` with exponential curves.
*   **Amplifier (VCA):** Controls the final volume, modulated by the Amp Envelope. Handled by `Tone.AmplitudeEnvelope` or a `Tone.Gain` node.
*   **LFO:** Provides modulation for pitch (vibrato), filter cutoff, and pulse width. We'll use `Tone.LFO`.
*   **Glide/Portamento:** Smooth pitch slides between notes. Handled by the `portamento` property in Tone.js oscillators.

## 3. Project Setup

1.  **Create a Project Folder:** Name it something like `web-sem-synth`.
2.  **Create Files:** Inside the folder, create three files:
    *   `index.html`
    *   `style.css`
    *   `synth.js`
3.  **Get Tone.js:**
    *   Download the latest `tone.min.js` from the [Tone.js GitHub releases](https://github.com/Tonejs/Tone.js/releases) or website.
    *   Place the `tone.min.js` file inside your project folder.
    *   Alternatively, you can link to a CDN in your HTML, but having it locally is good for offline use.

Your folder should look like this:

```
/web-sem-synth/
  ├── index.html
  ├── style.css
  ├── synth.js
  └── tone.min.js
```

## 4. HTML Code (`index.html`)

This file defines the user interface elements.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web SEM Synth</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Web SEM Synth</h1>

    <div class="global-controls">
        <button id="start-audio">Start Audio Context</button>
        <div class="midi-controls">
            <label for="midi-input">MIDI Input:</label>
            <select id="midi-input">
                <option>-- Select MIDI Device --</option>
            </select>
        </div>
         <div class="control-group">
             <label for="master-volume">Master Volume:</label>
             <input type="range" id="master-volume" min="0" max="1" value="0.7" step="0.01">
        </div>
         <div class="control-group">
             <label for="glide">Glide Time:</label>
             <input type="range" id="glide" min="0" max="1" value="0.05" step="0.01">
         </div>
    </div>


    <div class="synth-controls">
        <!-- VCO 1 Module -->
        <div class="module">
            <h2>VCO 1</h2>
            <div class="control-group">
                <label for="vco1-wave">Waveform:</label>
                <select id="vco1-wave">
                    <option value="sawtooth">Sawtooth</option>
                    <option value="pulse">Pulse</option>
                    <option value="triangle">Triangle</option> <!-- Added Triangle -->
                 </select>
            </div>
            <div class="control-group">
                <label for="vco1-detune">Fine Tune (cents):</label>
                <input type="range" id="vco1-detune" min="-50" max="50" value="0" step="1">
                <span class="value-display">0</span>
            </div>
             <div class="control-group">
                <label for="vco1-pwm-depth">PWM Depth (LFO):</label>
                <input type="range" id="vco1-pwm-depth" min="0" max="0.45" value="0" step="0.01">
                 <span class="value-display">0</span>
            </div>
        </div>

        <!-- VCO 2 Module -->
         <div class="module">
            <h2>VCO 2</h2>
             <div class="control-group">
                <label for="vco2-wave">Waveform:</label>
                <select id="vco2-wave">
                    <option value="sawtooth">Sawtooth</option>
                    <option value="pulse">Pulse</option>
                    <option value="triangle">Triangle</option> <!-- Added Triangle -->
                 </select>
            </div>
            <div class="control-group">
                <label for="vco2-detune">Fine Tune (cents):</label>
                <input type="range" id="vco2-detune" min="-50" max="50" value="-5" step="1">
                <span class="value-display">-5</span>
            </div>
             <div class="control-group">
                <label for="vco2-pwm-depth">PWM Depth (LFO):</label>
                <input type="range" id="vco2-pwm-depth" min="0" max="0.45" value="0" step="0.01">
                 <span class="value-display">0</span>
            </div>
        </div>

        <!-- Mixer Module -->
        <div class="module">
            <h2>Mixer</h2>
            <div class="control-group">
                <label for="mix-vco1">VCO 1 Level:</label>
                <input type="range" id="mix-vco1" min="0" max="1" value="0.7" step="0.01">
                <span class="value-display">0.7</span>
            </div>
            <div class="control-group">
                <label for="mix-vco2">VCO 2 Level:</label>
                <input type="range" id="mix-vco2" min="0" max="1" value="0.7" step="0.01">
                <span class="value-display">0.7</span>
            </div>
        </div>

        <!-- Filter (VCF) Module -->
        <div class="module">
            <h2>VCF (12dB SVF)</h2>
            <div class="control-group">
                <label for="filter-cutoff">Cutoff Freq (Hz):</label>
                <!-- Using min/max more perceptually linear via steps -->
                <input type="range" id="filter-cutoff" min="1" max="127" value="80" step="1">
                 <span class="value-display">~1000Hz</span> <!-- JS will update this -->
            </div>
            <div class="control-group">
                <label for="filter-q">Resonance (Q):</label>
                <input type="range" id="filter-q" min="0.1" max="20" value="1" step="0.1">
                <span class="value-display">1.0</span>
            </div>
            <div class="control-group">
                <label for="filter-sweep">LP/Notch/HP Sweep:</label>
                <input type="range" id="filter-sweep" min="0" max="1" value="0" step="0.01">
                <span class="value-display">LP</span> <!-- JS will update this -->
            </div>
            <div class="control-group">
                <label for="filter-env-amt">Env Amount:</label>
                <input type="range" id="filter-env-amt" min="-1" max="1" value="0.6" step="0.01">
                <span class="value-display">0.6</span>
            </div>
             <div class="control-group">
                <label for="filter-lfo-amt">LFO Amount:</label>
                <input type="range" id="filter-lfo-amt" min="0" max="1" value="0" step="0.01">
                 <span class="value-display">0</span>
            </div>
        </div>

         <!-- Filter Env (ADSR) Module -->
        <div class="module">
            <h2>Filter Envelope (ADSR)</h2>
             <div class="control-group"> <label for="filter-attack">Attack (s):</label> <input type="range" id="filter-attack" min="0.005" max="2" value="0.02" step="0.005"> <span class="value-display">0.02</span> </div>
             <div class="control-group"> <label for="filter-decay">Decay (s):</label> <input type="range" id="filter-decay" min="0.01" max="2" value="0.4" step="0.01"> <span class="value-display">0.4</span> </div>
             <div class="control-group"> <label for="filter-sustain">Sustain (0-1):</label> <input type="range" id="filter-sustain" min="0" max="1" value="0.5" step="0.01"> <span class="value-display">0.5</span> </div>
             <div class="control-group"> <label for="filter-release">Release (s):</label> <input type="range" id="filter-release" min="0.01" max="5" value="0.8" step="0.01"> <span class="value-display">0.8</span> </div>
        </div>

         <!-- Amp Env (ADSR) Module -->
        <div class="module">
            <h2>Amp Envelope (ADSR)</h2>
             <div class="control-group"> <label for="amp-attack">Attack (s):</label> <input type="range" id="amp-attack" min="0.005" max="2" value="0.01" step="0.005"> <span class="value-display">0.01</span> </div>
             <div class="control-group"> <label for="amp-decay">Decay (s):</label> <input type="range" id="amp-decay" min="0.01" max="2" value="0.2" step="0.01"> <span class="value-display">0.2</span> </div>
             <div class="control-group"> <label for="amp-sustain">Sustain (0-1):</label> <input type="range" id="amp-sustain" min="0" max="1" value="1.0" step="0.01"> <span class="value-display">1.0</span> </div>
             <div class="control-group"> <label for="amp-release">Release (s):</label> <input type="range" id="amp-release" min="0.01" max="5" value="0.5" step="0.01"> <span class="value-display">0.5</span> </div>
        </div>

         <!-- LFO Module -->
        <div class="module">
            <h2>LFO</h2>
             <div class="control-group">
                 <label for="lfo-wave">Waveform:</label>
                 <select id="lfo-wave">
                     <option value="triangle">Triangle</option>
                     <option value="sine">Sine</option>
                     <option value="square">Square</option>
                     <option value="sawtooth">Sawtooth</option>
                 </select>
             </div>
            <div class="control-group">
                <label for="lfo-rate">Rate (Hz):</label>
                <input type="range" id="lfo-rate" min="0.1" max="30" value="5" step="0.1">
                <span class="value-display">5.0</span>
            </div>
             <div class="control-group">
                <label for="lfo-vibrato-depth">Vibrato Depth (cents):</label>
                <input type="range" id="lfo-vibrato-depth" min="0" max="50" value="10" step="1">
                 <span class="value-display">10</span>
            </div>
        </div>

    </div>

    <!-- Include Tone.js -->
    <script src="tone.min.js"></script>
    <!-- Include your synth logic -->
    <script src="synth.js"></script>
</body>
</html>
```

## 5. CSS Code (`style.css`)

This provides basic styling for layout and appearance.

```css
body {
    font-family: sans-serif;
    background-color: #f0f0f0;
    color: #333;
    margin: 20px;
}

h1, h2 {
    color: #1a1a1a;
    border-bottom: 1px solid #ccc;
    padding-bottom: 5px;
    margin-top: 1.5em;
}

h1 {
    text-align: center;
    margin-bottom: 1em;
}

.global-controls {
    background-color: #e0e0e0;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    align-items: center;
}

#start-audio {
    padding: 10px 15px;
    font-size: 1em;
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
}

#start-audio:disabled {
    background-color: #aaa;
    cursor: default;
}

.midi-controls label,
.control-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    color: #555;
}

.midi-controls select,
.control-group select {
     padding: 5px;
     min-width: 150px;
}


.synth-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Responsive grid */
    gap: 20px;
}

.module {
    background-color: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
}

.module h2 {
    margin-top: 0;
    font-size: 1.2em;
}

.control-group {
    margin-bottom: 15px;
}

input[type="range"] {
    width: 100%;
    cursor: pointer;
}

/* Display current value next to slider */
.value-display {
    display: inline-block;
    margin-left: 10px;
    font-size: 0.85em;
    color: #666;
    min-width: 40px; /* Ensure space */
}

/* Make sliders take less vertical space if needed */
input[type=range] {
    vertical-align: middle; /* Align with label/value text */
}
label {
     vertical-align: middle;
}

```

## 6. JavaScript Code (`synth.js`)

This is the core logic connecting the UI, MIDI, and Tone.js audio components.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    // --- Global References ---
    let audioStarted = false;
    let vco1, vco2, vco1Gain, vco2Gain;
    let filterLp, filterHp, filterSweepXFade;
    let filterEnv, ampEnv;
    let lfo;
    let masterVolume;
    let currentNote = null; // Simple monophonic tracking
    const pitchBendRange = 2; // Semitones for pitch bend +/-

    // LFO->Parameter Gain Nodes (for controlling modulation depth)
    let lfoFilterModGain, lfoVco1PwmGain, lfoVco2PwmGain, lfoVibratoGain;

    // === DOM Element References ===
    const startButton = document.getElementById('start-audio');
    const midiInputSelector = document.getElementById('midi-input');
    const masterVolumeSlider = document.getElementById('master-volume');
    const glideSlider = document.getElementById('glide');

    // VCO1
    const vco1WaveSelect = document.getElementById('vco1-wave');
    const vco1DetuneSlider = document.getElementById('vco1-detune');
    const vco1PwmDepthSlider = document.getElementById('vco1-pwm-depth');
    // VCO2
    const vco2WaveSelect = document.getElementById('vco2-wave');
    const vco2DetuneSlider = document.getElementById('vco2-detune');
    const vco2PwmDepthSlider = document.getElementById('vco2-pwm-depth');
    // Mixer
    const mixVco1Slider = document.getElementById('mix-vco1');
    const mixVco2Slider = document.getElementById('mix-vco2');
    // Filter
    const filterCutoffSlider = document.getElementById('filter-cutoff');
    const filterQSlider = document.getElementById('filter-q');
    const filterSweepSlider = document.getElementById('filter-sweep');
    const filterEnvAmtSlider = document.getElementById('filter-env-amt');
    const filterLfoAmtSlider = document.getElementById('filter-lfo-amt');
    // Filter Env
    const filterAttackSlider = document.getElementById('filter-attack');
    const filterDecaySlider = document.getElementById('filter-decay');
    const filterSustainSlider = document.getElementById('filter-sustain');
    const filterReleaseSlider = document.getElementById('filter-release');
    // Amp Env
    const ampAttackSlider = document.getElementById('amp-attack');
    const ampDecaySlider = document.getElementById('amp-decay');
    const ampSustainSlider = document.getElementById('amp-sustain');
    const ampReleaseSlider = document.getElementById('amp-release');
    // LFO
    const lfoWaveSelect = document.getElementById('lfo-wave');
    const lfoRateSlider = document.getElementById('lfo-rate');
    const lfoVibratoDepthSlider = document.getElementById('lfo-vibrato-depth');

    // Value display elements
    const displays = {
        vco1Detune: vco1DetuneSlider.nextElementSibling,
        vco1PwmDepth: vco1PwmDepthSlider.nextElementSibling,
        vco2Detune: vco2DetuneSlider.nextElementSibling,
        vco2PwmDepth: vco2PwmDepthSlider.nextElementSibling,
        mixVco1: mixVco1Slider.nextElementSibling,
        mixVco2: mixVco2Slider.nextElementSibling,
        filterCutoff: filterCutoffSlider.nextElementSibling,
        filterQ: filterQSlider.nextElementSibling,
        filterSweep: filterSweepSlider.nextElementSibling,
        filterEnvAmt: filterEnvAmtSlider.nextElementSibling,
        filterLfoAmt: filterLfoAmtSlider.nextElementSibling,
        filterAttack: filterAttackSlider.nextElementSibling,
        filterDecay: filterDecaySlider.nextElementSibling,
        filterSustain: filterSustainSlider.nextElementSibling,
        filterRelease: filterReleaseSlider.nextElementSibling,
        ampAttack: ampAttackSlider.nextElementSibling,
        ampDecay: ampDecaySlider.nextElementSibling,
        ampSustain: ampSustainSlider.nextElementSibling,
        ampRelease: ampReleaseSlider.nextElementSibling,
        lfoRate: lfoRateSlider.nextElementSibling,
        lfoVibratoDepth: lfoVibratoDepthSlider.nextElementSibling
    };


    // --- Main Audio Setup Function ---
    async function setupAudio() {
        if (audioStarted) return;
        await Tone.start();
        console.log('Audio Context Started');
        audioStarted = true;
        startButton.disabled = true;
        startButton.textContent = 'Audio Running';

        // === Create Audio Nodes ===
        masterVolume = new Tone.Gain(parseFloat(masterVolumeSlider.value)).toDestination();

        // Envelopes (using default values from HTML initially)
        filterEnv = new Tone.Envelope({
            attack: parseFloat(filterAttackSlider.value), decay: parseFloat(filterDecaySlider.value),
            sustain: parseFloat(filterSustainSlider.value), release: parseFloat(filterReleaseSlider.value),
            attackCurve: 'exponential', releaseCurve: 'exponential'
        });
        ampEnv = new Tone.AmplitudeEnvelope({
            attack: parseFloat(ampAttackSlider.value), decay: parseFloat(ampDecaySlider.value),
            sustain: parseFloat(ampSustainSlider.value), release: parseFloat(ampReleaseSlider.value),
            attackCurve: 'exponential', releaseCurve: 'exponential'
        }).connect(masterVolume);


        // Filter Section (Sweepable LP/HP via Crossfade)
        const initialCutoffFreq = midiToFreq(parseFloat(filterCutoffSlider.value));
        const initialQ = parseFloat(filterQSlider.value);
        filterLp = new Tone.Filter({ frequency: initialCutoffFreq, type: 'lowpass', rolloff: -12, Q: initialQ });
        filterHp = new Tone.Filter({ frequency: initialCutoffFreq, type: 'highpass', rolloff: -12, Q: initialQ });
        filterSweepXFade = new Tone.CrossFade(parseFloat(filterSweepSlider.value)).connect(ampEnv); // Connect to Amp Env INSTEAD of master vol
        filterLp.connect(filterSweepXFade.a);
        filterHp.connect(filterSweepXFade.b);

        // Filter Env Amount (Bipolar) - Scales envelope output before adding to filter freq
        // This connects the filter envelope output to modulate the filter's frequency offset.
        const filterEnvModScale = 6000; // Max Hz sweep range for the filter envelope
        const filterEnvMod = new Tone.Scale(0, filterEnvModScale * parseFloat(filterEnvAmtSlider.value)); // Scaled envelope output
        filterEnv.connect(filterEnvMod);
        filterEnvMod.connect(filterLp.detune); // Modulate detune (in cents) for smoother control? Or frequency? Let's try detune.
        filterEnvMod.connect(filterHp.detune); // Detune is calculated relative to frequency signal.

        // Oscillators
        vco1 = new Tone.PulseOscillator({ // Use PulseOscillator for PWM compatibility
             frequency: 440, // Default frequency
             detune: parseFloat(vco1DetuneSlider.value),
             width: 0 // Width only active if type is 'pulse'
         });
         vco1.type = vco1WaveSelect.value; // Set initial type

        vco2 = new Tone.PulseOscillator({
            frequency: 440,
            detune: parseFloat(vco2DetuneSlider.value),
            width: 0
        });
         vco2.type = vco2WaveSelect.value; // Set initial type


        // Oscillator Gains (Mixer) - connect VCOs to Gains, Gains to *both* filters
        vco1Gain = new Tone.Gain(parseFloat(mixVco1Slider.value)).connect(filterLp).connect(filterHp);
        vco2Gain = new Tone.Gain(parseFloat(mixVco2Slider.value)).connect(filterLp).connect(filterHp);
        vco1.connect(vco1Gain);
        vco2.connect(vco2Gain);


        // LFO
        lfo = new Tone.LFO({
            frequency: parseFloat(lfoRateSlider.value),
            type: lfoWaveSelect.value,
            min: -1, // Bipolar for vibrato/filter mod
            max: 1
        });

        // LFO Routing Gain Nodes (initialize with UI values)
        const initialFilterLfoModHz = 3000; // Max LFO sweep in Hz
        lfoFilterModGain = new Tone.Scale(-initialFilterLfoModHz * parseFloat(filterLfoAmtSlider.value), initialFilterLfoModHz * parseFloat(filterLfoAmtSlider.value));
        lfo.connect(lfoFilterModGain);
        lfoFilterModGain.connect(filterLp.detune); // Modulate filter detune/offset
        lfoFilterModGain.connect(filterHp.detune);

        // LFO -> PWM Depth (Scale 0-1 LFO output to Pulse Width range 0 to ~0.9)
        lfoVco1PwmGain = new Tone.Scale(0, parseFloat(vco1PwmDepthSlider.value)); // Scale LFO output based on knob
        lfo.connect(lfoVco1PwmGain);
        lfoVco1PwmGain.connect(vco1.width); // Connect scaled LFO to VCO1 width

        lfoVco2PwmGain = new Tone.Scale(0, parseFloat(vco2PwmDepthSlider.value));
        lfo.connect(lfoVco2PwmGain);
        lfoVco2PwmGain.connect(vco2.width);

        // LFO -> Vibrato (Scale LFO +/-1 to +/- cents)
        lfoVibratoGain = new Tone.Scale(-parseFloat(lfoVibratoDepthSlider.value), parseFloat(lfoVibratoDepthSlider.value)); // +/- Cents
        lfo.connect(lfoVibratoGain);
        lfoVibratoGain.connect(vco1.detune); // Add LFO modulation to base detune
        lfoVibratoGain.connect(vco2.detune);


        // Start Oscillators and LFO
        vco1.start();
        vco2.start();
        lfo.start();

        // === Connect UI Controls ===
        connectUI();
        updateAllDisplays(); // Set initial display values

        // === Setup MIDI ===
        setupMIDI();
    }

    // --- UI Control Logic ---
    function connectUI() {
        // Helper to connect slider/select and update display
        function setupControl(element, parameterUpdater, displayKey = null) {
            element.addEventListener('input', (e) => {
                const value = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value;
                 if(audioStarted) { // Only update Tone nodes if audio is running
                    parameterUpdater(value, e.target);
                 }
                if (displayKey) {
                    updateDisplay(displayKey, value, e.target);
                }
            });
             // Set initial parameter value if audio already started (e.g., refresh)
             if(audioStarted) {
                 const initialValue = element.type === 'range' ? parseFloat(element.value) : element.value;
                 parameterUpdater(initialValue, element);
             }
        }

        // Global Controls
        setupControl(masterVolumeSlider, (v) => masterVolume.gain.rampTo(v, 0.02));
        setupControl(glideSlider, (v) => {
            vco1.portamento = v; vco2.portamento = v;
        });

        // VCO 1
        setupControl(vco1WaveSelect, (v) => vco1.type = v );
        setupControl(vco1DetuneSlider, (v) => vco1.detune.rampTo(v + (lfoVibratoGain.max > 0 ? lfoVibratoGain.value : 0), 0.02), 'vco1Detune'); // Add LFO offset manually if needed? Tone might handle it.
        setupControl(vco1PwmDepthSlider, (v) => lfoVco1PwmGain.max = v, 'vco1PwmDepth'); // Adjust max scale for PWM depth

        // VCO 2
        setupControl(vco2WaveSelect, (v) => vco2.type = v);
        setupControl(vco2DetuneSlider, (v) => vco2.detune.rampTo(v + (lfoVibratoGain.max > 0 ? lfoVibratoGain.value : 0), 0.02), 'vco2Detune');
        setupControl(vco2PwmDepthSlider, (v) => lfoVco2PwmGain.max = v, 'vco2PwmDepth'); // Adjust max scale

        // Mixer
        setupControl(mixVco1Slider, (v) => vco1Gain.gain.rampTo(v, 0.02), 'mixVco1');
        setupControl(mixVco2Slider, (v) => vco2Gain.gain.rampTo(v, 0.02), 'mixVco2');

        // Filter
        setupControl(filterCutoffSlider, (v) => {
            const freq = midiToFreq(v);
            filterLp.frequency.rampTo(freq, 0.02);
            filterHp.frequency.rampTo(freq, 0.02);
        }, 'filterCutoff');
        setupControl(filterQSlider, (v) => {
            filterLp.Q.rampTo(v, 0.02);
            filterHp.Q.rampTo(v, 0.02);
        }, 'filterQ');
        setupControl(filterSweepSlider, (v) => filterSweepXFade.fade.rampTo(v, 0.02), 'filterSweep');
        setupControl(filterEnvAmtSlider, (v) => filterEnvMod.max = 6000 * v, 'filterEnvAmt'); // Adjust max scale based on knob
        setupControl(filterLfoAmtSlider, (v) => {
             const maxModHz = 3000; // Sync with initial value
             lfoFilterModGain.min = -maxModHz * v;
             lfoFilterModGain.max = maxModHz * v;
        }, 'filterLfoAmt');


        // Filter Env
        setupControl(filterAttackSlider, (v) => filterEnv.attack = v, 'filterAttack');
        setupControl(filterDecaySlider, (v) => filterEnv.decay = v, 'filterDecay');
        setupControl(filterSustainSlider, (v) => filterEnv.sustain = v, 'filterSustain');
        setupControl(filterReleaseSlider, (v) => filterEnv.release = v, 'filterRelease');

        // Amp Env
        setupControl(ampAttackSlider, (v) => ampEnv.attack = v, 'ampAttack');
        setupControl(ampDecaySlider, (v) => ampEnv.decay = v, 'ampDecay');
        setupControl(ampSustainSlider, (v) => ampEnv.sustain = v, 'ampSustain');
        setupControl(ampReleaseSlider, (v) => ampEnv.release = v, 'ampRelease');

        // LFO
        setupControl(lfoWaveSelect, (v) => lfo.type = v);
        setupControl(lfoRateSlider, (v) => lfo.frequency.rampTo(v, 0.02), 'lfoRate');
        setupControl(lfoVibratoDepthSlider, (v) => {
            lfoVibratoGain.min = -v;
            lfoVibratoGain.max = v;
        }, 'lfoVibratoDepth');

    }

    // --- Update Display Values ---
     function midiToFreq(midiVal) {
        // Simple exponential mapping from slider range (1-127) to frequency (e.g., 20Hz - 18kHz)
        const minLog = Math.log(20);
        const maxLog = Math.log(18000);
        const scale = (maxLog - minLog) / (127 - 1);
        return Math.exp(minLog + scale * (midiVal - 1));
    }

    function updateDisplay(key, value, element) {
        if (!displays[key]) return;
         let displayValue = parseFloat(value).toFixed(2); // Default formatting

         // Custom formatting based on control type
         if (key === 'vco1Detune' || key === 'vco2Detune' || key === 'lfoVibratoDepth') {
             displayValue = parseInt(value);
         } else if (key === 'filterCutoff') {
              displayValue = midiToFreq(value).toFixed(0) + " Hz";
         } else if (key === 'filterSweep') {
              if (value < 0.1) displayValue = 'LP';
              else if (value > 0.9) displayValue = 'HP';
              else if (Math.abs(value - 0.5) < 0.1) displayValue = 'Notch';
              else displayValue = value.toFixed(2); // Show value between poles
         } else if (key === 'filterQ' || key === 'lfoRate') {
              displayValue = parseFloat(value).toFixed(1);
         } else if (key.includes('Attack') || key.includes('Decay') || key.includes('Release')) {
              displayValue = parseFloat(value).toFixed(3) + " s";
         } else if (key.includes('Sustain') || key.includes('mix') || key.includes('Amt') || key.includes('Depth') || key === 'master-volume') {
              displayValue = parseFloat(value).toFixed(2);
         }

        displays[key].textContent = displayValue;
    }

     function updateAllDisplays() {
         Object.keys(displays).forEach(key => {
             // Find the corresponding input element based on the display key
             // This mapping might need adjustment if IDs don't directly match
             let inputElement;
             if(key === 'vco1Detune') inputElement = vco1DetuneSlider;
             else if(key === 'vco1PwmDepth') inputElement = vco1PwmDepthSlider;
             else if(key === 'vco2Detune') inputElement = vco2DetuneSlider;
             else if(key === 'vco2PwmDepth') inputElement = vco2PwmDepthSlider;
             else if(key === 'mixVco1') inputElement = mixVco1Slider;
              else if(key === 'mixVco2') inputElement = mixVco2Slider;
             else if(key === 'filterCutoff') inputElement = filterCutoffSlider;
             else if(key === 'filterQ') inputElement = filterQSlider;
             else if(key === 'filterSweep') inputElement = filterSweepSlider;
             else if(key === 'filterEnvAmt') inputElement = filterEnvAmtSlider;
             else if(key === 'filterLfoAmt') inputElement = filterLfoAmtSlider;
             else if(key === 'filterAttack') inputElement = filterAttackSlider;
             else if(key === 'filterDecay') inputElement = filterDecaySlider;
             else if(key === 'filterSustain') inputElement = filterSustainSlider;
             else if(key === 'filterRelease') inputElement = filterReleaseSlider;
             else if(key === 'ampAttack') inputElement = ampAttackSlider;
             else if(key === 'ampDecay') inputElement = ampDecaySlider;
             else if(key === 'ampSustain') inputElement = ampSustainSlider;
             else if(key === 'ampRelease') inputElement = ampReleaseSlider;
             else if(key === 'lfoRate') inputElement = lfoRateSlider;
             else if(key === 'lfoVibratoDepth') inputElement = lfoVibratoDepthSlider;
             // Add more mappings if needed

             if (inputElement) {
                 updateDisplay(key, inputElement.value, inputElement);
             }
         });
     }


    // --- MIDI Handling ---
    function setupMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess({ sysex: false }) // Sysex not needed
                .then(onMIDISuccess, onMIDIFailure);
        } else {
            console.warn("WebMIDI is not supported in this browser.");
            midiInputSelector.innerHTML = '<option>Not Supported</option>';
            midiInputSelector.disabled = true;
        }
    }

    function onMIDISuccess(midiAccess) {
        console.log("MIDI ready!");
        let inputs = midiAccess.inputs;
        if (inputs.size === 0) {
            midiInputSelector.innerHTML = '<option>No MIDI devices found</option>';
            midiInputSelector.disabled = true;
            return;
        }

        midiInputSelector.innerHTML = '<option value="">-- Select MIDI Device --</option>'; // Placeholder
        inputs.forEach(input => {
            const option = document.createElement('option');
            option.value = input.id;
            option.text = input.name;
            midiInputSelector.appendChild(option);
            console.log(`Found MIDI input: ID=${input.id}, Name=${input.name}`);
            // Automatically listen to the first device found? Or wait for selection?
            // Let's wait for selection via the dropdown.
        });
         midiInputSelector.disabled = false; // Enable dropdown

        // Clear existing listeners before adding a new one
        let currentInput = null;
        midiInputSelector.onchange = () => {
            // Remove listener from previous input if any
            if (currentInput && currentInput.onmidimessage) {
                 console.log(`Stopping listener on ${currentInput.name}`);
                currentInput.onmidimessage = null;
            }
            const selectedId = midiInputSelector.value;
            if (selectedId) {
                currentInput = midiAccess.inputs.get(selectedId);
                if (currentInput) {
                    console.log(`Starting listener on ${currentInput.name}`);
                    currentInput.onmidimessage = handleMIDIMessage;
                }
            } else {
                currentInput = null; // No device selected
            }
        };

        midiAccess.onstatechange = (event) => {
             console.log(`MIDI state change: ${event.port.name} state: ${event.port.state}`);
             // Rescan and populate MIDI inputs on change
             onMIDISuccess(midiAccess);
        };
    }


    function onMIDIFailure(msg) {
        console.error(`Failed to get MIDI access - ${msg}`);
         midiInputSelector.innerHTML = '<option>MIDI Access Failed</option>';
         midiInputSelector.disabled = true;
    }

    function handleMIDIMessage(event) {
        if (!audioStarted) return; // Don't process MIDI if audio not started

        const command = event.data[0] >> 4; // Command is the upper nibble (e.g., 9=NoteOn, 8=NoteOff, 11=CC, 14=PitchBend)
        const channel = event.data[0] & 0xf; // Channel is the lower nibble (0-15)
        const data1 = event.data[1]; // Note number or CC number
        const data2 = event.data.length > 2 ? event.data[2] : 0; // Velocity or CC value

        const time = Tone.now(); // Use Tone.now() for precise timing

        switch (command) {
            case 9: // Note On
                if (data2 > 0) { // Velocity > 0 means Note On
                    noteOn(data1, data2, time);
                } else {
                    // Some controllers send Note On with velocity 0 for Note Off
                    noteOff(data1, time);
                }
                break;
            case 8: // Note Off
                noteOff(data1, time);
                break;
            case 11: // Control Change (CC)
                handleCC(data1, data2); // data1=CC number, data2=CC value
                break;
            case 14: // Pitch Bend
                // Combine MSB and LSB for pitch bend value
                const bendValue = ((data2 << 7) | data1) - 8192; // Range -8192 to +8191
                handlePitchBend(bendValue);
                break;
        }
    }

    function noteOn(midiNote, velocity, time) {
        console.log(`Note On: ${midiNote}, Vel: ${velocity}`);
        currentNote = midiNote;
        const freq = Tone.Frequency(midiNote, "midi").toFrequency();
        const velNorm = velocity / 127;

        // Set oscillator frequencies (with portamento respecting glide time)
        vco1.frequency.setValueAtTime(freq, time);
        vco2.frequency.setValueAtTime(freq, time);

        // Trigger envelopes
        // Scale amp envelope output by velocity (adjust curve to taste)
        const ampModVelocity = Math.pow(velNorm, 1.5) * 0.8 + 0.2; // Make velocity more expressive
        ampEnv.triggerAttack(time, ampModVelocity);
        filterEnv.triggerAttack(time); // Filter env usually not velocity sensitive on SEM?
    }

    function noteOff(midiNote, time) {
        // Only trigger release if the note being released is the one currently playing (monophonic)
        if (midiNote === currentNote) {
            console.log(`Note Off: ${midiNote}`);
            ampEnv.triggerRelease(time);
            filterEnv.triggerRelease(time);
            currentNote = null; // Ready for next note
        }
    }

     function handlePitchBend(bendValue) {
        if(!audioStarted) return;
        // Calculate bend amount in cents
        const bendAmount = (bendValue / 8192) * pitchBendRange * 100; // +/- cents

        // Apply bend smoothly to the detune parameter *relative to the base detune*
        const bendRampTime = 0.01; // Smoothness for pitch bend changes

         // Get current base detune from sliders
        const baseDetune1 = parseFloat(vco1DetuneSlider.value);
        const baseDetune2 = parseFloat(vco2DetuneSlider.value);

        // Add LFO modulation and pitch bend to the base detune
        const targetDetune1 = baseDetune1 + lfoVibratoGain.value + bendAmount;
        const targetDetune2 = baseDetune2 + lfoVibratoGain.value + bendAmount;

        vco1.detune.rampTo(targetDetune1, bendRampTime);
        vco2.detune.rampTo(targetDetune2, bendRampTime);
    }


    function handleCC(ccNumber, ccValue) {
        if(!audioStarted) return;
        console.log(`CC Received: ${ccNumber}, Value: ${ccValue}`);
        const valueNorm = ccValue / 127; // Normalized value 0-1
         const rampTime = 0.02; // Smoothness for CC changes

        // --- Example CC Mappings ---
        switch (ccNumber) {
            case 1: // Mod Wheel (Commonly LFO Depth for Vibrato/Filter)
                // Map Mod Wheel to LFO->Vibrato Depth
                const maxVibrato = 50; // Max cents controlled by Mod Wheel
                lfoVibratoGain.min = -valueNorm * maxVibrato;
                lfoVibratoGain.max = valueNorm * maxVibrato;
                lfoVibratoDepthSlider.value = valueNorm * maxVibrato; // Update UI
                 updateDisplay('lfoVibratoDepth', lfoVibratoDepthSlider.value, lfoVibratoDepthSlider);

                 // Optional: Map Mod Wheel to LFO->Filter Depth as well
                const maxFilterMod = 3000; // Max Hz mod controlled by Mod Wheel
                lfoFilterModGain.min = -valueNorm * maxFilterMod;
                lfoFilterModGain.max = valueNorm * maxFilterMod;
                 filterLfoAmtSlider.value = valueNorm; // Update UI (0-1 range)
                 updateDisplay('filterLfoAmt', filterLfoAmtSlider.value, filterLfoAmtSlider);
                break;

            case 74: // Filter Cutoff (Brightness/Filter Freq)
                // Map CC value (0-127) directly to filter cutoff slider range (1-127)
                filterCutoffSlider.value = ccValue;
                 // Trigger the 'input' event to update the filter frequency and display
                filterCutoffSlider.dispatchEvent(new Event('input'));
                break;

            case 71: // Filter Resonance (Timbre/Resonance)
                 // Map CC value (0-127) to filter Q range (0.1 - 20)
                const minQ = 0.1; const maxQ = 20;
                const q = minQ + valueNorm * (maxQ - minQ);
                filterQSlider.value = q;
                filterQSlider.dispatchEvent(new Event('input')); // Update filter Q and display
                break;

             case 5: // Portamento Time (Glide)
                glideSlider.value = valueNorm; // Map 0-127 to 0-1 range
                 glideSlider.dispatchEvent(new Event('input')); // Update glide time
                break;

            // Add more CC mappings here for envelopes, LFO rate, mix levels etc.
            // case 73: // Amp Env Attack Time (often CC 73)
            //    const maxAttack = 2; // Max attack time in seconds
            //    ampAttackSlider.value = valueNorm * maxAttack;
            //    ampAttackSlider.dispatchEvent(new Event('input'));
            //    break;
            // case 72: // Amp Env Release Time (often CC 72)
            //    const maxRelease = 5; // Max release time
            //    ampReleaseSlider.value = valueNorm * maxRelease;
            //    ampReleaseSlider.dispatchEvent(new Event('input'));
            //    break;

        }
    }


    // --- Event Listener for Start Button ---
    startButton.addEventListener('click', setupAudio);

}); // End DOMContentLoaded
```

## 7. Running the Synthesizer

1.  **Save Files:** Make sure all three files (`index.html`, `style.css`, `synth.js`) and `tone.min.js` are in the same folder.
2.  **Open HTML:** Open the `index.html` file in a modern web browser that supports the Web Audio and Web MIDI APIs (like Chrome, Firefox, Edge, Safari). Double-clicking the file should work.
3.  **Start Audio:** Click the "Start Audio Context" button. This is required by browsers to enable audio.
4.  **Select MIDI Input:** If you have a MIDI controller connected *before* loading the page, it should appear in the "MIDI Input" dropdown menu. Select your device.
5.  **Play:** Play notes on your MIDI keyboard. You should hear sound!
6.  **Adjust Controls:** Use the sliders and dropdowns on the page to shape the sound. Connect your Mod Wheel (CC 1) or other mapped CC controllers.

## 8. Key Implementation Notes & Sound Tips

*   **Filter:** The parallel LP/HP filter with `Tone.CrossFade` is an *approximation* of the SEM's variable filter mode. It captures the LP-Notch-HP sweep characteristic. Experiment with the Cutoff and Resonance controls.
*   **"Analog" Feel:**
    *   The slight detuning between VCO 1 and VCO 2 adds richness.
    *   The exponential envelope curves (`attackCurve: 'exponential'`, etc.) provide a more natural feel than linear envelopes.
    *   *Optional:* For more drift, you could add another *very* slow `Tone.LFO` modulating the `detune` of each VCO slightly and independently (e.g., +/- 1-3 cents).
*   **PWM:** Ensure the Oscillator Waveform is set to "Pulse" for Pulse Width Modulation via the LFO to have an effect.
*   **Logarithmic Controls:** Frequency and sometimes time controls often feel more intuitive with logarithmic scaling. The filter cutoff slider uses a simple MIDI-to-Frequency mapping for a somewhat logarithmic feel. You could implement more precise logarithmic mapping in JavaScript if desired.
*   **CPU Usage:** Complex synths can be CPU-intensive. Keep an eye on performance, especially if adding more features.
*   **No Hard Sync:** This implementation omits oscillator hard sync, a feature of the SEM, due to the complexity of implementing it reliably with standard Web Audio nodes. `AudioWorklets` would be required for a more accurate implementation.

## 9. Further Exploration

*   Add more modulation destinations for the LFO (e.g., Mixer levels).
*   Implement keyboard tracking for the filter cutoff.
*   Add basic effects like Delay (`Tone.FeedbackDelay`) or Reverb (`Tone.Reverb`).
*   Improve the UI with more visual feedback or different controls (e.g., rotary knobs via JS libraries).
*   Explore `AudioWorklets` for features like hard sync or custom filter modeling.
*   Add subtle saturation (`Tone.Chebyshev` order 2 or `Tone.WaveShaper`) post-filter or pre-master volume for more analog warmth.

## 10. Disclaimer

This synthesizer is *inspired* by the Oberheim SEM. It aims to capture its core architecture and some key sonic characteristics using readily available web technologies. It is not a circuit-perfect emulation. Enjoy experimenting!

--- END OF PDF CONTENT ---